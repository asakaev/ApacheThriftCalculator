

/**
 * @typedef {?function(!Object.<string, string>):!Object.<string, string>}
 */
tio.thrift.HeadersFilter;


/**
 * @typedef {?{
 *   installer: !tio.thrift.HeadersFilter,
 *   extractor: !tio.thrift.HeadersFilter
 * }}
 */
tio.thrift.HeaderOptions;


/**
 * @param {function(!tio.thrift.Message)} complete
 * @param {!yaa.ErrorHandler} cancel
 * @param {!thrift.protocol.IProtocol} protocol
 * @param {!http.IncomingMessage} stream
 * @param {!tio.thrift.HeadersFilter=} opt_headerExtractor
 */
tio.thrift.decode = function(complete, cancel, protocol, stream,
                             opt_headerExtractor) {
  var payload = [];
  var size = 0;

  /**
   * @param {!Buffer} chunk
   */
  function process(chunk) {
    payload.push(chunk);
    size += chunk.length;
  }

  function decode() {
    stream.removeAllListeners();

    var handler = thrift.protocol.MESSAGE_HANDLER(protocol);
    handler.process(new thrift.Cursor(), Buffer.concat(payload, size));

    var message = handler.get();
    if (message instanceof thrift.Message) {
      var value = message.getValue();
      if (value instanceof Array) {
        complete(new tio.thrift.Message(message.getId(), message.getName(),
            value, opt_headerExtractor ?
                opt_headerExtractor(stream.headers) : stream.headers));
      } else {
        cancel(value);
      }
    } else {
      cancel('Incorrect message payload.');
    }
  }

  stream.addListener('data', process);
  stream.addListener('close', decode);
  stream.addListener('error', decode);
  stream.addListener('end', decode);
};
